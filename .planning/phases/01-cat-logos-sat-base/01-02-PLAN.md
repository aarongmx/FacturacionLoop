---
phase: 01-cat-logos-sat-base
plan: 02
type: execute
wave: 2
depends_on:
  - 01-01
files_modified:
  - database/seeders/RegimenFiscalSeeder.php
  - database/seeders/UsoCfdiSeeder.php
  - database/seeders/FormaPagoSeeder.php
  - database/seeders/MetodoPagoSeeder.php
  - database/seeders/TipoDeComprobanteSeeder.php
  - database/seeders/ImpuestoSeeder.php
  - database/seeders/TipoFactorSeeder.php
  - database/seeders/ObjetoImpSeeder.php
  - database/seeders/TipoRelacionSeeder.php
  - database/seeders/ClaveProdServSeeder.php
  - database/seeders/ClaveUnidadSeeder.php
  - database/seeders/TasaOCuotaSeeder.php
  - database/seeders/DatabaseSeeder.php
autonomous: false
requirements:
  - CAT-01
  - CAT-02
  - CAT-03
  - CAT-04
  - CAT-05
  - CAT-06
  - CAT-07
  - CAT-08
  - CAT-09
  - CAT-10
  - CAT-11
  - CAT-12
must_haves:
  truths:
    - "Running php artisan db:seed populates all 12 catalog tables with SAT data from CSV files"
    - "Re-running seeders does not duplicate data — upsert on conflict key updates existing rows"
    - "c_ClaveProdServ table contains approximately 53,000 rows after seeding"
    - "c_ClaveUnidad table contains approximately 2,000 rows after seeding"
    - "All small catalogs contain the expected number of rows (e.g., RegimenFiscal ~22, FormaPago ~30)"
  artifacts:
    - path: "database/seeders/ClaveProdServSeeder.php"
      provides: "Chunked CSV seeder for 53K product/service keys"
      contains: "upsert"
    - path: "database/seeders/DatabaseSeeder.php"
      provides: "Master seeder calling all 12 catalog seeders"
      contains: "RegimenFiscalSeeder"
    - path: "database/data/c_RegimenFiscal.csv"
      provides: "CSV source data for regimenes fiscales"
  key_links:
    - from: "database/seeders/RegimenFiscalSeeder.php"
      to: "database/data/c_RegimenFiscal.csv"
      via: "fgetcsv reads CSV file"
      pattern: "fgetcsv"
    - from: "database/seeders/DatabaseSeeder.php"
      to: "database/seeders/*Seeder.php"
      via: "$this->call() registration"
      pattern: "this->call"
---

<objective>
Convert SAT XLS catalog data to CSV files and create all 12 seeders that populate the database from those CSV files using chunked upsert.

Purpose: Without seeded data, catalog tables are empty — Filament resources show nothing, and CFDI forms have no dropdown options.
Output: 12 CSV files in `database/data/`, 12 seeder classes using `fgetcsv` + `DB::table()->upsert()`, updated `DatabaseSeeder.php`.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-cat-logos-sat-base/01-RESEARCH.md
@.planning/phases/01-cat-logos-sat-base/01-01-SUMMARY.md

<interfaces>
<!-- Seeder pattern from RESEARCH.md: -->

```php
final class RegimenFiscalSeeder extends Seeder
{
    public function run(): void
    {
        $csvPath = database_path('data/c_RegimenFiscal.csv');
        if (! file_exists($csvPath)) {
            $this->command->warn("CSV not found: {$csvPath}. Skipping.");
            return;
        }
        $handle = fopen($csvPath, 'r');
        fgetcsv($handle); // skip header
        $chunk = [];
        while (($row = fgetcsv($handle)) !== false) {
            if (empty($row[0])) { continue; }
            $chunk[] = [
                'clave' => trim($row[0]),
                'descripcion' => trim($row[1]),
                // ... catalog-specific columns
                'created_at' => now(),
                'updated_at' => now(),
            ];
            if (count($chunk) >= 500) {
                DB::table('regimenes_fiscales')->upsert(
                    $chunk,
                    uniqueBy: ['clave'],
                    update: ['descripcion', ..., 'updated_at']
                );
                $chunk = [];
            }
        }
        if ($chunk !== []) {
            DB::table('regimenes_fiscales')->upsert($chunk, uniqueBy: ['clave'], update: [..., 'updated_at']);
        }
        fclose($handle);
    }
}
```
</interfaces>
</context>

<tasks>

<task type="checkpoint:human-action" gate="blocking">
  <name>Task 1: User converts XLS sheets to CSV files</name>
  <action>
The SAT catalog data exists only as XLS (binary Excel 97-2003) files in `database/data/catCFDI_V_4_20260212.xls`. PHP's `fgetcsv` cannot read XLS files — only CSV. The user must export each relevant sheet to a CSV file.

**IMPORTANT:** This is a one-time manual step. The resulting CSV files will be committed to git and used by all seeders.
  </action>
  <how-to-verify>
Open `database/data/catCFDI_V_4_20260212.xls` in LibreOffice Calc or Microsoft Excel. For each of the following sheets, export as CSV (UTF-8, comma-separated) to `database/data/`:

1. Sheet `c_RegimenFiscal` → save as `database/data/c_RegimenFiscal.csv`
2. Sheet `c_UsoCFDI` → save as `database/data/c_UsoCFDI.csv`
3. Sheet `c_FormaPago` → save as `database/data/c_FormaPago.csv`
4. Sheet `c_MetodoPago` → save as `database/data/c_MetodoPago.csv`
5. Sheet `c_TipoDeComprobante` → save as `database/data/c_TipoDeComprobante.csv`
6. Sheet `c_ClaveProdServ` → save as `database/data/c_ClaveProdServ.csv` (this is the large one, ~53K rows)
7. Sheet `c_ClaveUnidad` → save as `database/data/c_ClaveUnidad.csv` (~2K rows)
8. Sheet `c_Impuesto` → save as `database/data/c_Impuesto.csv`
9. Sheet `c_TipoFactor` → save as `database/data/c_TipoFactor.csv`
10. Sheet `c_TasaOCuota` → save as `database/data/c_TasaOCuota.csv`
11. Sheet `c_ObjetoImp` → save as `database/data/c_ObjetoImp.csv`
12. Sheet `c_TipoRelacion` → save as `database/data/c_TipoRelacion.csv`

**Export settings:** UTF-8 encoding, comma delimiter, double-quote text qualifier. Keep the header row (first row with column names).

After exporting, verify each CSV file exists and has data:
```bash
wc -l database/data/c_*.csv
```
  </how-to-verify>
  <resume-signal>Type "done" after all 12 CSV files are exported to database/data/</resume-signal>
</task>

<task type="auto">
  <name>Task 2: Create seeders for all 12 SAT catalogs using fgetcsv + upsert</name>
  <files>
    database/seeders/RegimenFiscalSeeder.php
    database/seeders/UsoCfdiSeeder.php
    database/seeders/FormaPagoSeeder.php
    database/seeders/MetodoPagoSeeder.php
    database/seeders/TipoDeComprobanteSeeder.php
    database/seeders/ImpuestoSeeder.php
    database/seeders/TipoFactorSeeder.php
    database/seeders/ObjetoImpSeeder.php
    database/seeders/TipoRelacionSeeder.php
    database/seeders/ClaveProdServSeeder.php
    database/seeders/ClaveUnidadSeeder.php
    database/seeders/TasaOCuotaSeeder.php
  </files>
  <action>
Create 12 seeder classes. Use `php artisan make:seeder` to scaffold, then implement. Every seeder follows the same pattern:

1. Read CSV from `database_path('data/c_{CatalogName}.csv')`
2. Skip header row with `fgetcsv($handle)`
3. Build chunks of 500 rows
4. Use `DB::table('{table_name}')->upsert($chunk, uniqueBy: ['{conflict_key}'], update: [{update_columns}])` for each chunk
5. Handle remaining chunk after loop
6. Guard with `file_exists()` check — warn and skip if CSV missing

**CRITICAL: NEVER use `truncate()`. Use `upsert()` only.** This is a locked user decision. Existing records may be referenced by invoices in later phases.

**Column mapping per seeder (CSV column index → database column):**

1. **RegimenFiscalSeeder** → table `regimenes_fiscales`, uniqueBy `clave`:
   - `$row[0]` → `clave`, `$row[1]` → `descripcion`, `$row[2]` → `aplica_fisica` (compare to 'Sí'), `$row[3]` → `aplica_moral` (compare to 'Sí'), `$row[4]` → `vigencia_inicio` (empty string to null), `$row[5]` → `vigencia_fin`

2. **UsoCfdiSeeder** → table `usos_cfdi`, uniqueBy `clave`:
   - Same structure as RegimenFiscal: clave, descripcion, aplica_fisica, aplica_moral, vigencia_inicio, vigencia_fin

3. **FormaPagoSeeder** → table `formas_pago`, uniqueBy `clave`:
   - `$row[0]` → `clave`, `$row[1]` → `descripcion`, `$row[2]` → `bancarizado` (compare to 'Sí'), `$row[3]` → `vigencia_inicio`, `$row[4]` → `vigencia_fin`

4. **MetodoPagoSeeder** → table `metodos_pago`, uniqueBy `clave`:
   - `$row[0]` → `clave`, `$row[1]` → `descripcion`, `$row[2]` → `vigencia_inicio`, `$row[3]` → `vigencia_fin`

5. **TipoDeComprobanteSeeder** → table `tipos_comprobante`, uniqueBy `clave`:
   - `$row[0]` → `clave`, `$row[1]` → `descripcion`, `$row[2]` → `vigencia_inicio`, `$row[3]` → `vigencia_fin`

6. **ImpuestoSeeder** → table `impuestos`, uniqueBy `clave`:
   - `$row[0]` → `clave`, `$row[1]` → `descripcion`, `$row[2]` → `vigencia_inicio`, `$row[3]` → `vigencia_fin`

7. **TipoFactorSeeder** → table `tipos_factor`, uniqueBy `clave`:
   - `$row[0]` → `clave`, `$row[1]` → `descripcion`, `$row[2]` → `vigencia_inicio`, `$row[3]` → `vigencia_fin`

8. **ObjetoImpSeeder** → table `objetos_imp`, uniqueBy `clave`:
   - `$row[0]` → `clave`, `$row[1]` → `descripcion`, `$row[2]` → `vigencia_inicio`, `$row[3]` → `vigencia_fin`

9. **TipoRelacionSeeder** → table `tipos_relacion`, uniqueBy `clave`:
   - `$row[0]` → `clave`, `$row[1]` → `descripcion`, `$row[2]` → `vigencia_inicio`, `$row[3]` → `vigencia_fin`

10. **ClaveProdServSeeder** → table `claves_prod_serv`, uniqueBy `clave`:
    - `$row[0]` → `clave`, `$row[1]` → `descripcion`, `$row[2]` → `incluye_iva`, `$row[3]` → `incluye_ieps`, `$row[4]` → `complemento`, `$row[5]` → `vigencia_inicio`, `$row[6]` → `vigencia_fin`, `$row[7]` → `estimulo_franja` (compare to 'Sí'), `$row[8]` → `palabras_similares`
    - **IMPORTANT:** Use chunk size of 500 to handle 53K rows efficiently. Wrap in `DB::transaction()` per chunk for consistency.

11. **ClaveUnidadSeeder** → table `claves_unidad`, uniqueBy `clave`:
    - `$row[0]` → `clave`, `$row[1]` → `nombre`, `$row[2]` → `descripcion`, `$row[3]` → `nota`, `$row[4]` → `vigencia_inicio`, `$row[5]` → `vigencia_fin`, `$row[6]` → `simbolo`

12. **TasaOCuotaSeeder** → table `tasas_o_cuotas`, uniqueBy composite `['impuesto', 'factor', 'valor_minimo', 'valor_maximo', 'traslado', 'retencion']`:
    - Read the actual CSV header to determine column order. Expected: tipo, valor_minimo, valor_maximo, impuesto, factor, traslado (Sí/No), retencion (Sí/No), vigencia_inicio, vigencia_fin
    - The composite unique key is critical — this is the only catalog without a single-column PK

**Date handling:** Empty strings in CSV → `null` in DB. Non-empty date strings should be stored as-is (SAT uses 'YYYY-MM-DD' or 'DD/MM/YYYY' format — check the actual CSV and convert to 'Y-m-d' if needed).

**Boolean handling:** Compare trimmed value to 'Sí' (case-sensitive, with accent). Be careful with encoding.

After creating all seeders, run `vendor/bin/pint --dirty --format agent`.
  </action>
  <verify>
    <automated>cd /home/aarongmx/Proyectos/FacturacionLoop && php artisan db:seed --class=RegimenFiscalSeeder 2>&1 && php artisan tinker --execute="echo App\Models\RegimenFiscal::count();" 2>&1</automated>
  </verify>
  <done>All 12 seeder files exist and implement fgetcsv + upsert pattern. Each seeder reads from the corresponding CSV file in database/data/. No seeder uses truncate(). Re-running a seeder on already-populated data does not create duplicates.</done>
</task>

<task type="auto">
  <name>Task 3: Register all catalog seeders in DatabaseSeeder and run full seed</name>
  <files>
    database/seeders/DatabaseSeeder.php
  </files>
  <action>
Update `database/seeders/DatabaseSeeder.php` to call all 12 new catalog seeders via `$this->call([...])`. Add them AFTER the existing test user creation. Order matters for the TasaOCuota seeder — it references Impuesto, so ImpuestoSeeder must run first.

```php
$this->call([
    RegimenFiscalSeeder::class,
    UsoCfdiSeeder::class,
    FormaPagoSeeder::class,
    MetodoPagoSeeder::class,
    TipoDeComprobanteSeeder::class,
    ImpuestoSeeder::class,      // Must run before TasaOCuotaSeeder
    TipoFactorSeeder::class,
    TasaOCuotaSeeder::class,    // References impuestos table
    ObjetoImpSeeder::class,
    TipoRelacionSeeder::class,
    ClaveProdServSeeder::class,
    ClaveUnidadSeeder::class,
]);
```

Then run `php artisan migrate:fresh --seed` to verify the full pipeline from scratch. Verify row counts match expected values (RegimenFiscal ~22, ClaveProdServ should be large, MetodoPago = 2, etc.).

Run `vendor/bin/pint --dirty --format agent`.
  </action>
  <verify>
    <automated>cd /home/aarongmx/Proyectos/FacturacionLoop && php artisan migrate:fresh --seed --force 2>&1 | tail -20</automated>
  </verify>
  <done>DatabaseSeeder calls all 12 catalog seeders in correct order. Running `php artisan migrate:fresh --seed` populates all tables from CSV data. All PHP files pass Pint.</done>
</task>

</tasks>

<verification>
- `php artisan migrate:fresh --seed` runs without errors
- `php artisan tinker --execute="echo App\Models\RegimenFiscal::count();"` returns > 0
- `php artisan tinker --execute="echo App\Models\ClaveProdServ::count();"` returns > 50000
- `php artisan tinker --execute="echo App\Models\ClaveUnidad::count();"` returns > 1000
- Re-running `php artisan db:seed` does not duplicate records
- `vendor/bin/pint --dirty --format agent` reports no changes
</verification>

<success_criteria>
- All 12 CSV files exist in `database/data/`
- All 12 seeder classes implement fgetcsv + upsert (no truncate)
- DatabaseSeeder calls all 12 seeders in dependency-safe order
- Full seed populates all tables with real SAT data
- Idempotent seeding: re-running does not duplicate rows
</success_criteria>

<output>
After completion, create `.planning/phases/01-cat-logos-sat-base/01-02-SUMMARY.md`
</output>
