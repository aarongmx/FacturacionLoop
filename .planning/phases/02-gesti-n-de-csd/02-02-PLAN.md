---
phase: 02-gesti-n-de-csd
plan: 02
type: execute
wave: 2
depends_on: [02-01]
files_modified:
  - app/Actions/UploadCsdAction.php
  - app/Actions/ActivateCsdAction.php
  - app/Actions/DeactivateCsdAction.php
  - app/Actions/ValidateCsdExpiryAction.php
autonomous: true
requirements:
  - CSD-01
  - CSD-02
  - CSD-04
  - CSD-05
  - CSD-06
must_haves:
  truths:
    - "UploadCsdAction validates .cer/.key pair using Credential::openFiles(), extracts NoCertificado/RFC/dates, encrypts .key contents with Crypt::encryptString(), stores encrypted file in private storage, stores .cer in private storage, and creates a Csd record"
    - "UploadCsdAction throws RuntimeException with Spanish message when pair validation fails or certificate is not a CSD"
    - "UploadCsdAction deletes temp upload files after processing"
    - "ActivateCsdAction deactivates the current active CSD (if any) and sets the given CSD as active — only one active CSD at a time"
    - "DeactivateCsdAction sets the given CSD status to Inactive"
    - "ValidateCsdExpiryAction throws RuntimeException when the active CSD is expired or when no active CSD exists"
  artifacts:
    - path: "app/Actions/UploadCsdAction.php"
      provides: "Invokable action: validate pair, extract metadata, encrypt .key, persist Csd"
      contains: "Credential::openFiles"
    - path: "app/Actions/ActivateCsdAction.php"
      provides: "Invokable action: deactivate current active, set new as active"
      contains: "CsdStatus::Active"
    - path: "app/Actions/DeactivateCsdAction.php"
      provides: "Invokable action: set status to Inactive"
      contains: "CsdStatus::Inactive"
    - path: "app/Actions/ValidateCsdExpiryAction.php"
      provides: "Invokable action: throws if expired or no active CSD"
      contains: "RuntimeException"
  key_links:
    - from: "app/Actions/UploadCsdAction.php"
      to: "app/Data/UploadCsdData.php"
      via: "Method parameter type"
      pattern: "UploadCsdData $data"
    - from: "app/Actions/UploadCsdAction.php"
      to: "app/Models/Csd.php"
      via: "Creates Csd records"
      pattern: "Csd::create"
    - from: "app/Actions/ValidateCsdExpiryAction.php"
      to: "app/Builders/CsdBuilder.php"
      via: "Uses custom builder methods"
      pattern: "whereActive"
---

<objective>
Create the four domain action classes that implement all CSD business logic.

Purpose: These actions encapsulate the core domain operations — uploading/validating certificates, managing active status, and enforcing expiry rules. They are consumed by the Filament resource (Plan 03) and tested in Plan 04. Phase 4 (CFDI stamping) will consume ValidateCsdExpiryAction to block expired CSDs.
Output: 4 invokable action classes in `app/Actions/`, all following the locked decision of single-responsibility, transactional, invokable actions with `declare(strict_types=1)`.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-gesti-n-de-csd/02-RESEARCH.md
@.planning/phases/02-gesti-n-de-csd/02-01-SUMMARY.md

<interfaces>
<!-- From 02-01-PLAN: Csd model (created in Plan 01) -->

```php
<?php
declare(strict_types=1);
namespace App\Models;

use App\Builders\CsdBuilder;
use App\Enums\CsdStatus;
use Database\Factories\CsdFactory;
use Illuminate\Database\Eloquent\Attributes\UseEloquentBuilder;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\SoftDeletes;
use Override;

#[UseEloquentBuilder(CsdBuilder::class)]
final class Csd extends Model
{
    use HasFactory;
    use SoftDeletes;

    protected $fillable = [
        'no_certificado', 'rfc', 'fecha_inicio', 'fecha_fin',
        'status', 'key_path', 'passphrase_encrypted', 'cer_path',
    ];

    public function casts(): array
    {
        return [
            'fecha_inicio' => 'date',
            'fecha_fin' => 'date',
            'status' => CsdStatus::class,
            'passphrase_encrypted' => 'encrypted',
        ];
    }
}
```

<!-- From 02-01-PLAN: CsdStatus enum -->

```php
enum CsdStatus: string implements HasColor, HasLabel
{
    case Active       = 'active';
    case ExpiringSoon = 'expiring_soon';
    case Expired      = 'expired';
    case Inactive     = 'inactive';
}
```

<!-- From 02-01-PLAN: UploadCsdData DTO -->

```php
final class UploadCsdData extends Data
{
    public function __construct(
        public string $cerFilePath,
        public string $keyFilePath,
        public string $passphrase,
    ) {}
}
```

<!-- From 02-01-PLAN: CsdBuilder -->

```php
final class CsdBuilder extends Builder
{
    public function whereActive(): static { ... }
    public function whereExpiring(int $withinDays = 90): static { ... }
    public function whereNotExpired(): static { ... }
}
```

<!-- From RESEARCH: phpcfdi/credentials API -->

```php
use PhpCfdi\Credentials\Credential;

$credential = Credential::openFiles($cerPath, $keyPath, $passphrase);
// Throws UnexpectedValueException if pair mismatch or wrong passphrase

$cert = $credential->certificate();
$cert->serialNumber()->bytes();    // NoCertificado string
$cert->rfc();                      // RFC string
$cert->validFromDateTime();        // DateTimeImmutable
$cert->validToDateTime();          // DateTimeImmutable
$credential->isCsd();              // bool
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create UploadCsdAction</name>
  <files>
    app/Actions/UploadCsdAction.php
  </files>
  <action>
Create `app/Actions/` directory if it does not exist. Then create `app/Actions/UploadCsdAction.php`.

This is the most complex action — it orchestrates:
1. Pair validation via `Credential::openFiles()`
2. CSD type verification via `$credential->isCsd()`
3. Metadata extraction (NoCertificado, RFC, validity dates)
4. .key file encryption and storage in private disk
5. .cer file storage in private disk
6. Csd model creation with initial status determination
7. Temp file cleanup

```php
declare(strict_types=1);

namespace App\Actions;

use App\Data\UploadCsdData;
use App\Enums\CsdStatus;
use App\Models\Csd;
use Carbon\Carbon;
use Illuminate\Support\Facades\Crypt;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Storage;
use PhpCfdi\Credentials\Credential;
use RuntimeException;
use UnexpectedValueException;

final class UploadCsdAction
{
    /**
     * @throws RuntimeException When .cer/.key pair is invalid, passphrase is wrong, or certificate is not a CSD
     */
    public function __invoke(UploadCsdData $data): Csd
    {
        // Step 1: Validate the .cer/.key pair and passphrase
        try {
            $credential = Credential::openFiles(
                $data->cerFilePath,
                $data->keyFilePath,
                $data->passphrase,
            );
        } catch (UnexpectedValueException $e) {
            throw new RuntimeException(
                'El certificado y la llave privada no coinciden, o la contraseña es incorrecta.',
                previous: $e,
            );
        }

        // Step 2: Verify it is a CSD (not FIEL)
        if (! $credential->isCsd()) {
            throw new RuntimeException(
                'El archivo .cer no es un Certificado de Sello Digital (CSD). Verifique que no sea una FIEL.',
            );
        }

        $certificate = $credential->certificate();

        // Step 3: Extract metadata
        // Use validFromDateTime()/validToDateTime() which return DateTimeImmutable — safer than string parsing
        $noCertificado = $certificate->serialNumber()->bytes();
        $rfc           = $certificate->rfc();
        $fechaInicio   = Carbon::instance($certificate->validFromDateTime());
        $fechaFin      = Carbon::instance($certificate->validToDateTime());

        // Step 4: Determine initial status based on expiry
        $status = match (true) {
            $fechaFin->isPast()                   => CsdStatus::Expired,
            $fechaFin->lte(now()->addDays(90))    => CsdStatus::ExpiringSoon,
            default                               => CsdStatus::Inactive,
        };

        // Step 5: Encrypt and store .key file contents in private storage
        $keyContents  = file_get_contents($data->keyFilePath);
        $encryptedKey = Crypt::encryptString($keyContents);
        $keyStorePath = 'csd/' . $noCertificado . '.key.enc';
        Storage::disk('local')->put($keyStorePath, $encryptedKey);

        // Step 6: Store .cer file in private storage (not encrypted — needed as-is for XML signing)
        $cerContents  = file_get_contents($data->cerFilePath);
        $cerStorePath = 'csd/' . $noCertificado . '.cer';
        Storage::disk('local')->put($cerStorePath, $cerContents);

        // Step 7: Persist the CSD record within a transaction
        $csd = DB::transaction(fn (): Csd => Csd::create([
            'no_certificado'       => $noCertificado,
            'rfc'                  => $rfc,
            'fecha_inicio'         => $fechaInicio,
            'fecha_fin'            => $fechaFin,
            'status'               => $status,
            'key_path'             => $keyStorePath,
            'passphrase_encrypted' => $data->passphrase, // 'encrypted' cast handles encryption on save
            'cer_path'             => $cerStorePath,
        ]));

        // Step 8: Clean up temp upload files
        // Delete temp files if they exist in the temp upload directory
        if (file_exists($data->cerFilePath)) {
            @unlink($data->cerFilePath);
        }
        if (file_exists($data->keyFilePath)) {
            @unlink($data->keyFilePath);
        }

        return $csd;
    }
}
```

**Key decisions:**
- Uses `Carbon::instance($certificate->validFromDateTime())` — NOT the string `validFrom()` method (pitfall from research)
- .cer file stored unencrypted because Phase 4 XML signing needs the raw .cer bytes
- .key file contents encrypted with `Crypt::encryptString()` before storage (defense-in-depth per locked decision)
- Passphrase assigned as plaintext to `passphrase_encrypted` — the `'encrypted'` cast auto-encrypts on save
- Status auto-determined: Expired if past, ExpiringSoon if within 90 days, otherwise Inactive (never auto-Active)
- Temp files cleaned up after processing (prevents unencrypted .key lingering in temp storage)

Run `vendor/bin/pint --dirty --format agent` after creating the file.
  </action>
  <verify>
    <automated>cd /home/aarongmx/Proyectos/FacturacionLoop && test -f app/Actions/UploadCsdAction.php && ./vendor/bin/sail php -l app/Actions/UploadCsdAction.php && vendor/bin/pint --dirty --format agent 2>&1 | tail -3</automated>
  </verify>
  <done>UploadCsdAction.php exists, has no syntax errors, follows the invokable pattern with UploadCsdData parameter, validates pair, extracts metadata, encrypts .key, stores .cer, creates Csd with correct status, and cleans temp files.</done>
</task>

<task type="auto">
  <name>Task 2: Create ActivateCsdAction, DeactivateCsdAction, and ValidateCsdExpiryAction</name>
  <files>
    app/Actions/ActivateCsdAction.php
    app/Actions/DeactivateCsdAction.php
    app/Actions/ValidateCsdExpiryAction.php
  </files>
  <action>
**ActivateCsdAction** — Sets a CSD as the active signing certificate. Only one CSD can be active at a time. Deactivates the current active CSD (if any) before activating the new one. Uses a DB transaction for atomicity.

```php
declare(strict_types=1);

namespace App\Actions;

use App\Enums\CsdStatus;
use App\Models\Csd;
use Illuminate\Support\Facades\DB;
use RuntimeException;

final class ActivateCsdAction
{
    /**
     * @throws RuntimeException When the CSD is expired
     */
    public function __invoke(Csd $csd): Csd
    {
        if ($csd->fecha_fin->isPast()) {
            throw new RuntimeException(
                'No se puede activar un CSD expirado. Suba un nuevo certificado.',
            );
        }

        DB::transaction(function () use ($csd): void {
            // Deactivate the current active CSD (if any)
            Csd::query()
                ->whereActive()
                ->where('id', '!=', $csd->id)
                ->update(['status' => CsdStatus::Inactive]);

            // Activate the given CSD
            $csd->update(['status' => CsdStatus::Active]);
        });

        return $csd->refresh();
    }
}
```

**DeactivateCsdAction** — Sets a CSD status to Inactive. Per locked decision: deactivating the only active CSD is allowed but should be noted (the caller in Filament will show a warning).

```php
declare(strict_types=1);

namespace App\Actions;

use App\Enums\CsdStatus;
use App\Models\Csd;

final class DeactivateCsdAction
{
    public function __invoke(Csd $csd): Csd
    {
        $csd->update(['status' => CsdStatus::Inactive]);

        return $csd->refresh();
    }
}
```

**ValidateCsdExpiryAction** — Validates that there is an active, non-expired CSD available for signing. Phase 4 stamping pipeline will call this before contacting the PAC.

```php
declare(strict_types=1);

namespace App\Actions;

use App\Models\Csd;
use RuntimeException;

final class ValidateCsdExpiryAction
{
    /**
     * Returns the active CSD if valid.
     *
     * @throws RuntimeException When no active CSD exists or the active CSD is expired
     */
    public function __invoke(): Csd
    {
        $activeCsd = Csd::query()->whereActive()->first();

        if ($activeCsd === null) {
            throw new RuntimeException(
                'No hay CSD activo. Configure un certificado antes de timbrar.',
            );
        }

        if ($activeCsd->fecha_fin->isPast()) {
            throw new RuntimeException(
                'El CSD está expirado. Suba un nuevo certificado antes de timbrar.',
            );
        }

        return $activeCsd;
    }
}
```

All four actions follow the locked decisions:
- `declare(strict_types=1)` in every file
- Invokable (`__invoke`) pattern
- Single-responsibility
- Transactional where needed (ActivateCsdAction)
- `final class`
- Spanish error messages (localization decision)

Run `vendor/bin/pint --dirty --format agent` after creating all files.
  </action>
  <verify>
    <automated>cd /home/aarongmx/Proyectos/FacturacionLoop && ./vendor/bin/sail php -l app/Actions/ActivateCsdAction.php && ./vendor/bin/sail php -l app/Actions/DeactivateCsdAction.php && ./vendor/bin/sail php -l app/Actions/ValidateCsdExpiryAction.php && vendor/bin/pint --dirty --format agent 2>&1 | tail -3</automated>
  </verify>
  <done>ActivateCsdAction deactivates current active and sets new as active within a transaction, refuses expired CSDs. DeactivateCsdAction sets status to Inactive. ValidateCsdExpiryAction throws if no active CSD or if active CSD is expired. All files are final, invokable, strict_types, and pass Pint.</done>
</task>

</tasks>

<verification>
- All 4 action files exist in `app/Actions/`
- All files have `declare(strict_types=1)`, `final class`, `__invoke()` method
- `./vendor/bin/sail php -l app/Actions/*.php` reports no syntax errors
- `vendor/bin/pint --dirty --format agent` reports no changes needed
- `./vendor/bin/sail php artisan test --compact` passes (no regressions)
</verification>

<success_criteria>
- UploadCsdAction: validates pair, verifies CSD type, extracts metadata, encrypts .key, stores .cer, creates Csd, cleans temp files
- ActivateCsdAction: deactivates current active CSD, activates new one, refuses expired CSDs, transactional
- DeactivateCsdAction: sets status to Inactive
- ValidateCsdExpiryAction: returns active CSD or throws RuntimeException with Spanish message
- All actions are invokable, single-responsibility, and follow project conventions
</success_criteria>

<output>
After completion, create `.planning/phases/02-gesti-n-de-csd/02-02-SUMMARY.md`
</output>
